# takes different masks generated by different versions/runs of deepcell and compares them

import numpy as np
import os
import skimage.io as io
import copy
from skimage.measure import label
from skimage.morphology import watershed
from skimage.feature import peak_local_max
import skimage.filters.rank as rank


# get directory where images are located
base_dir = '/Users/noahgreenwald/Documents/Grad_School/Lab/Segmentation_Project/Contours/First_Run/'
image_dir = base_dir + 'analyses/20190505_deepcell_old/'
plot_dir = image_dir + '/Figs/'

# get names of each, clean up for subsequent saving
files = os.listdir(image_dir)
files = [file for file in files if 'npy' in file]
files.sort()
prefix = files[0].split("interior")[0]
names = files
names = [x.replace(prefix, '').replace('_metrics.npy', '') for x in names]

# load single point to get dimensions
temp = np.load(image_dir + files[0])
# load all data into a single numpy array
data = np.zeros(((len(files), ) + temp.shape), dtype='float32')
# axes on data: training run, image, x_dim, y_dim, output_mask
for i in range(len(files)):
    data[i, :, :, :, :] = np.load(os.path.join(image_dir, files[i]))


# save images back to folder for viewing from regular network
for i in range(len(files)):
    if data.shape[-1] == 3:
        # three category network
        border_idx = 0
        nuc_idx = 1
        io.imsave(os.path.join(image_dir, names[i] + '_nucleus.tiff'), data[i, 3, :, :, nuc_idx])
        io.imsave(os.path.join(image_dir, names[i] + '_border.tiff'), data[i, 3, :, :, border_idx])
    else:
        # 4 category network
        border_idx = [0, 1]
        nuc_idx = 2
        io.imsave(os.path.join(image_dir, names[i] + '_nucleus.tiff'), data[i, 3, :, :, nuc_idx])
        io.imsave(os.path.join(image_dir, names[i] + '_border.tiff'),
                  data[i, 3, :, :, border_idx[0]] + data[i, 3, :, :, border_idx[1]])


# save watershed energy levels back to disk for watershed transform input
for j in range(data.shape[0]):
    print("j = {}".format(j))
    # save all FOVs processed by jth network into test_images
    test_images = data[j, ..., 0:4]

    # find max value of different masks for each FOV
    argmax_images = []
    for i in range(test_images.shape[0]):
        argmax_images.append(np.argmax(test_images[i], axis=-1))
    argmax_images = np.array(argmax_images)
    argmax_images = np.expand_dims(argmax_images, axis=-1)

    threshold = 0.6
    test_images_fgbg = data[j, ..., 4:6]
    fg_thresh = test_images_fgbg[..., 1] > threshold
    fg_thresh = np.expand_dims(fg_thresh, axis=-1)

    argmax_images_post_fgbg = argmax_images * fg_thresh
    smoothed_argmax = rank.median(argmax_images_post_fgbg[3, :, :, 0], np.ones((5, 5)))

    # save relevant tifs
    io.imsave(os.path.join(image_dir, names[j] + '_smoothed_probs.tiff'), smoothed_argmax.astype('int16'))
    io.imsave(os.path.join(image_dir, names[j] + '_nucleus.tiff'), fg_thresh[0, :, :, 0].astype('int16'))


# # remove labels from border regions of mask that correspond to empy areas in deepcell 1.0
# # set padding
# pad = 0
# row = 0
# while pad == 0:
#     if np.sum(predicted_data[row, :] > 0):
#         pad = row
#     else:
#         row += 1
#
# pad_mask = np.zeros((1024, 1024), dtype="bool")
# pad_mask[0:30, :] = True
# pad_mask[:, 0:30] = True
# pad_mask[:, -30:-1] = True
# pad_mask[-30:-1, :] = True
# remove_ids = np.unique(contour_L[pad_mask])
# remove_idx = np.isin(contour_L, remove_ids)
# contour_data[contour_L == 0] = 0
# contour_data[pad_mask] = 0
#
# padded_contour = Image.fromarray(contour_data)
# padded_contour.save(image_direc + '/Nuclear_Interior_Mask_padded.tif')
#
#
# # regenerate object IDs after removing regions that overlap with padding
# contour_L, contour_idx = skimage.measure.label(contour_data,return_num=True, connectivity=1)
# contour_props = skimage.measure.regionprops(contour_L)
