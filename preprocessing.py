# takes different masks generated by different versions/runs of deepcell and compares them

import numpy as np
import os
import skimage.io as io
import copy
from skimage.measure import label
from skimage.morphology import watershed
from skimage.feature import peak_local_max

# get directory where images are located
base_dir = '/Users/noahgreenwald/Documents/Grad_School/Lab/Segmentation_Project/Contours/First_Run/'
image_dir = base_dir + 'analyses/190429_watershed_network/'
plot_dir = image_dir + '/Figs/'

# get names of each, clean up for subsequent saving
files = os.listdir(image_dir)
files = [file for file in files if 'npy' in file]
prefix = files[0].split("interior")[0]
names = files
names = [x.replace(prefix, '').replace('_metrics.npy', '') for x in names]

# load all data into a single numpy array
data = np.zeros((len(files), 4, 1024, 1024, 4), dtype='float32')
# axes on data: training run, image, x_dim, y_dim, output_mask
for i in range(len(files)):
    data[i, :, :, :, :] = np.load(os.path.join(image_dir, files[i]))


# save images back to folder for viewing from regular network
for i in range(len(files)):
    io.imsave(os.path.join(image_dir, names[i] + '_nucleus.tiff'), data[i, 3, :, :, 2])
    io.imsave(os.path.join(image_dir, names[i] + '_border.tiff'), data[i, 3, :, :, 1])


# save watershed transform and nuclear probabilities back to disk for watershed network output
for j in range(data.shape[0]):
    print("j = {}".format(j))
    # save all FOVs processed by jth network into test_images
    test_images = data[j, ...]

    # find max value of different masks for each FOV
    argmax_images = []
    for i in range(test_images.shape[0]):
        argmax_images.append(np.argmax(test_images[i], axis=-1))
    argmax_images = np.array(argmax_images)
    argmax_images = np.expand_dims(argmax_images, axis=-1)

    # already did during evaluation on docker
    # threshold = 0.9
    # fg_thresh = test_images_fgbg[..., 1] > threshold
    # fg_thresh = np.expand_dims(fg_thresh, axis=-1)

    argmax_images_post_fgbg = argmax_images
    fg_thresh = argmax_images_post_fgbg[..., 0] > 0
    watershed_images = []

    # only evaluate on last image in stack
    # for i in range(argmax_images_post_fgbg.shape[0]):
    for k in [3]:
        image = fg_thresh[k, ...]
        distance = argmax_images_post_fgbg[k, ..., 0]

        local_maxi = peak_local_max(test_images[k, ..., -1],
                                    min_distance=5,
                                    exclude_border=False,
                                    indices=False,
                                    labels=image)

        markers = label(local_maxi)
        segments = watershed(-distance, markers, mask=image, watershed_line=True)
        watershed_images.append(segments)

    watershed_images = np.array(watershed_images)
    watershed_images = np.expand_dims(watershed_images, axis=-1)
    io.imsave(os.path.join(image_dir, names[j] + '_nucleus.tiff'), argmax_images_post_fgbg[3, :, :, 0].astype('int16'))
    io.imsave(os.path.join(image_dir, 'mask_python_' + names[j] + '.tiff'), watershed_images[0, :, :, 0])





# # remove labels from border regions of mask that correspond to empy areas in deepcell 1.0
# # set padding
# pad = 0
# row = 0
# while pad == 0:
#     if np.sum(predicted_data[row, :] > 0):
#         pad = row
#     else:
#         row += 1
#
# pad_mask = np.zeros((1024, 1024), dtype="bool")
# pad_mask[0:30, :] = True
# pad_mask[:, 0:30] = True
# pad_mask[:, -30:-1] = True
# pad_mask[-30:-1, :] = True
# remove_ids = np.unique(contour_L[pad_mask])
# remove_idx = np.isin(contour_L, remove_ids)
# contour_data[contour_L == 0] = 0
# contour_data[pad_mask] = 0
#
# padded_contour = Image.fromarray(contour_data)
# padded_contour.save(image_direc + '/Nuclear_Interior_Mask_padded.tif')
#
#
# # regenerate object IDs after removing regions that overlap with padding
# contour_L, contour_idx = skimage.measure.label(contour_data,return_num=True, connectivity=1)
# contour_props = skimage.measure.regionprops(contour_L)
